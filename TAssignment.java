import java.awt.*;import java.io.*;public class TAssignment {	int TrafficProducedataNode[];   //// at a network node	int TrafficAttractedtoaNode[];    //// at a network node	float Attraction[];   ////// the resulting attraction function for each node	double denom[];    //// its the resulting denominator in the gravity model.......denom[i] = sum(j) (Attraction[j] * f(i, j))	FloatStack TrafficonaLink[], SymmTrafficonaLink[];	boolean symmetry;				int vertices;	int nodes;		float coeff;  ///// coefficent in friction function		boolean OnlyOnce = true;	float totalTrips = 0;		public TAssignment( float coeff) {		this.coeff = coeff;	}		public void trafficassignment(DirectedGraph dgraph, Automata ca, DijkstrasAlgo dalgo, boolean symm, Demo demo,int period) {				symmetry = symm;				int edges;				vertices = dgraph.Vertices();		edges = dgraph.Edges();				nodes = (int) Math.sqrt( vertices);				int s = ca.size(); 								/// set traffic production and attraction functions		if(OnlyOnce) {						TrafficProducedataNode = new int[vertices];			TrafficAttractedtoaNode = new int[vertices];		 	Attraction = new float[vertices];		 	denom = new double[vertices];		 			 				 for(int i=0; i<vertices;i++) {		 		TrafficAttractedtoaNode[i] = 0;		 		TrafficProducedataNode[i] = 0;		 	}						for(int i=0; i<s; i++ ) {				for(int j=0; j<s; j++) {					TrafficProducedataNode[ca.nearestnn(i, j)-1] += ca.landuse(i, j); 				}			}			for(int i=0; i<s; i++ ) {				for(int j=0; j<s; j++) {					TrafficAttractedtoaNode[ca.nearestnn(i, j)-1] += ca.landuse2(i, j); 				}			}						/*			System.out.print("Traffic Produced:   ");			for(int i=0; i<vertices; i++) { 				totalTrips += TrafficProducedataNode[i];				System.out.print(TrafficProducedataNode[i]+"  ");			}			System.out.println();						System.out.print("Traffic Attracted:  ");			for(int i=0; i<vertices; i++)				System.out.print(TrafficAttractedtoaNode[i] +"  ");			System.out.println();						System.out.println(totalTrips);			*/						//printTrafficVolumeatNode();						OnlyOnce = false;					}				///////   Trip_Distribution     ///// ca.landuse is production and ca.landuse2 is attraction		{						float oldAttraction[] = new float[vertices];			float newAttraction[] = new float[vertices];			float error = 2;						//System.out.println("Starting Trip Distribution");									for(int i=0; i<vertices; i++)				Attraction[i] = newAttraction[i] = TrafficAttractedtoaNode[i];						int iterationCounter = 0;						while(error> 0.5) {								iterationCounter++;				error = 0;								//// step 1:   set denom =0; and oldattraction = newattraction				for(int i=0; i<vertices; i++) {					denom[i] = 0;					oldAttraction[i] = newAttraction[i];					newAttraction[i] = 0;					//System.out.print(oldAttraction[i] + "  ");				}				//System.out.println();								//// step 2:  calculate the new Attractions using the previous oldAttraction				for(int i=0; i<vertices; i++)					{												Attraction[i] = TrafficAttractedtoaNode[i]*Attraction[i]/oldAttraction[i];																		} 								//// step 3:  calculate denom with the new Attractions				for(int i=0; i<vertices; i++)					for(int j=0; j<vertices; j++)						if(i!=j)						denom[i] +=Attraction[j]*Math.exp( -coeff*dalgo.pLabel(i+1, j+1) );									//// step 4:  calculate newAttraction using denom and Attraction				for(int j=0; j<vertices; j++) {					for(int i=0; i<vertices; i++)						if( i!= j)							newAttraction[j] += TrafficProducedataNode[i]*Math.exp( -coeff*dalgo.pLabel(i+1, j+1) )/denom[i];					//System.out.print("\nextra1="+Math.exp( -coeff*dalgo.pLabel(i+1, j+1) )+"\textra2="+denom[i] );}											newAttraction[j] *= Attraction[j];				}								//// step 5:  calculate error. error = square root of sum of squares of deviation rom previous results				for(int i=0; i<vertices; i++)					error += Math.pow( (oldAttraction[i] - newAttraction[i] ),  2);									error = (float)Math.sqrt( error);													}			//			System.out.println(iterationCounter);								}		demo.dp.showStatus.setText("End of Trip Distribution...");		demo.dp.showStatus.repaint() ;			//		System.out.println("End of Trip Distribution");				////  Traffic Assignment according to shortest path		{			//System.out.println("Starting Traffic Assignment");					TrafficonaLink = new FloatStack[vertices];			int tempNode=0,leadingNode=0, followingNode=0;						for(int i=0; i<vertices; i++) {				TrafficonaLink[i] = new FloatStack(dgraph.NoofLinks(i+1));				for(int j=0; j<dgraph.NoofLinks(i+1);j++) 					TrafficonaLink[i].push(0);			}							//assign 						for(int i=0; i<vertices; i++) {	//// for each node of the graph as the origin of the shortest path				for(int j=vertices-1;j>=1; j--) {      					//// for each element from the end of the shortest path					//// find its previously connected permanent node along the shortest path until the orign ithNode is reached										followingNode=dalgo.s[i][j];  //Node Number of the element in the permanent vector					leadingNode=dalgo.pi[i][followingNode-1];// the predecessor,which is DIRECTLY connected to the node 															do					{												int K=-1;					a:	for(int k=0;k<dgraph.NoofLinks(leadingNode);k++){							if(dgraph.EndNodeNumbers( leadingNode, k+1 )==followingNode)								{K=k;break a;} 														}												//System.out.println("i+1="+(i+1)+" following="+followingNode+" leadingNode="+leadingNode+" K="+K);												float tempTraffic = TrafficonaLink[leadingNode-1].access(K)+ ODMatrix(i, dalgo.s[i][j]-1, (float)dalgo.pLabel(i+1, dalgo.s[i][j]) )+ ODMatrix(dalgo.s[i][j]-1, i, (float)dalgo.pLabel(dalgo.s[i][j], i+1))  ; ////						TrafficonaLink[leadingNode-1].replace(K, tempTraffic );						//System.out.print("\ndenom="+denom[i]);						followingNode=leadingNode;						leadingNode=dalgo.pi[i][followingNode-1];					}						while(followingNode!=i+1);				}									}		}			//		if(period==1){//			writeODmatrixFile(dalgo,dgraph);//			writeFlowFile(dalgo,dgraph);//			}						if (symmetry)			symmetricVolume(dgraph);				//printTrafficonaLink();					//avergeTrafficonaLink(dgraph);				//printTrafficonaLink();		//System.out.println("End of Traffic Assingment.");		//System.out.println();				demo.dp.showStatus.setText("End of Traffic Assignment...");		demo.dp.showStatus.repaint() ;						}			//dimension int width,int height	private int node( Dimension d ) {		return (int) (d.width*nodes+d.height+1);		}		private Dimension  node(int nodeNumber) {				int i = (int) (nodeNumber % nodes) ;				if(  i == 0)			return new Dimension (  (int) (nodeNumber / nodes) -1, nodes-1 );		else 			return new Dimension( (int) (nodeNumber/nodes), i-1 );				}		private Dimension imageV_Axis( Dimension d) {		return new Dimension( d.width, nodes-d.height-1);	}		private Dimension imageH_Axis( Dimension d) {		return new Dimension( nodes-d.width-1, d.height);	}		private Dimension diagonalImage( Dimension d) {		return new Dimension( d.height, d.width);	}		private void symmetricVolume(DirectedGraph dgraph) {				Dimension originD[] = new Dimension[8];		Dimension destD[] = new Dimension[8];				SymmTrafficonaLink = new FloatStack[vertices];		for(int i=0; i<vertices; i++) {			SymmTrafficonaLink[i] = new FloatStack(dgraph.NoofLinks(i+1));			for(int j=0; j<dgraph.NoofLinks(i+1);j++) 				SymmTrafficonaLink[i].push(0);		}				for(int k=0; k<8; k++) {			originD[k] = new Dimension();			destD[k] = new Dimension();		}							for( int i=0; i<vertices; i++) {			for(int j=0; j<dgraph.NoofLinks(i+1); j++) {				float sum;				sum = 0;				int endNode ; 				endNode = dgraph.EndNodeNumbers( i+1, j+1);												originD[0].setSize( node(i+1) );				destD[0].setSize( node(endNode) );								originD[1].setSize( imageV_Axis( originD[0] )  );				destD[1].setSize( imageV_Axis ( destD[0] ) );								originD[2].setSize( imageH_Axis( originD[1] )  );				destD[2].setSize( imageH_Axis ( destD[1] )   );								originD[3].setSize( imageV_Axis( originD[2] )   );				destD[3].setSize( imageV_Axis ( destD[2] )    );										originD[4].setSize( diagonalImage( originD[0] )  );				destD[4].setSize( diagonalImage( destD[0] ) );								originD[5].setSize( imageV_Axis( originD[4] )   );				destD[5].setSize( imageV_Axis ( destD[4] )   );								originD[6].setSize( imageH_Axis( originD[5] )   );				destD[6].setSize( imageH_Axis ( destD[5] )    );								originD[7].setSize( imageV_Axis( originD[6] )   );				destD[7].setSize( imageV_Axis ( destD[6] )   );								for(int k =0; k<8 ; k++) {					int firstNN = node( originD[k] );					int secondNN = node( destD[k]);					int position = dgraph.Position_EndNode( firstNN, secondNN);										sum += TrafficonaLink[firstNN-1].access( position-1);												}								SymmTrafficonaLink[i].replace(j, (float)(sum/8) );			}		}				for(int i=0; i<vertices; i++) {			for(int j=0; j<dgraph.NoofLinks(i+1); j++) {								float temp = TrafficonaLink[i].access(j);				TrafficonaLink[i].replace(j, SymmTrafficonaLink[i].access(j) );				SymmTrafficonaLink[i].replace(j, temp);								}		}										}		private void avergeTrafficonaLink(DirectedGraph dgraph){		for( int i=0; i<vertices; i++) {			for(int j=0; j<dgraph.NoofLinks(i+1); j++) {								float sum;				sum = 0;				int endNode ; 				endNode = dgraph.EndNodeNumbers( i+1, j+1);																		sum += TrafficonaLink[i].access( j);									int position = dgraph.Position_EndNode( endNode,i+1);										sum += TrafficonaLink[endNode-1].access( position-1);									TrafficonaLink[i].replace(j, (float)(sum/2) );						TrafficonaLink[endNode-1].replace(position-1,(float)(sum/2));						}						}			}				////// i, j = 0, 1, 2 ...vertices-1	public float  ODMatrix(int i, int j, float tt) {//tt indicates the value of generanized cost		if(i!=j)			return( (float) (TrafficProducedataNode[i] * Attraction[j]*Math.exp(-coeff*tt)/denom[i] ) );		else			return(0);	}		public void printODMatrix(DijkstrasAlgo dalgo) {		System.out.println("Origin - Destination (OD) Matrix:  ");		for(int i=0; i<TrafficProducedataNode.length; i++) {			for(int j=0; j<TrafficProducedataNode.length;j++) {				System.out.print(       ODMatrix(i, j, (float)dalgo.pLabel(i+1, j+1) )+ODMatrix(j, i, (float)dalgo.pLabel(j+1, i+1) )   );				System.out.print(" ");			}			System.out.println();		}		System.out.println();			}			///////// FirstNN = {1,2,3...vertices} SecondNN = {node number thats connected to FirstNN  }		public float TrafficonaLink(DirectedGraph dgraph, int FirstNN, int SecondNN) {		int position = 0;		if(  dgraph.Connected(FirstNN, SecondNN)  ) {			for(int i=0; i< dgraph.NoofLinks(FirstNN); i++) {				if(dgraph.EndNodeNumbers(FirstNN, i) == SecondNN )					position = i;			}		} else {			System.out.println("Fron TrafficAssignment class:  In TrafficonLink Method nodes are not connected returning 0");			return 0;		}				return (TrafficonaLink[FirstNN-1].access(position));			}		////////// FirstNN = {1,2,3.....vertices}, SecondNP = { 1,2...dgraph.NoofLinks(FirstNN) }	public float TrafficonaLink_2(DirectedGraph dgraph, int FirstNN, int SecondNP) {		if ( (FirstNN >=1 && FirstNN <= dgraph.Vertices()) && (SecondNP >=1 && SecondNP <= dgraph.NoofLinks(FirstNN) ) ) {			return (TrafficonaLink[FirstNN-1].access(SecondNP-1));		} else {			System.out.println("From TrafficAssignment class: In TrafficonaLink_2 method arguments are out of range! returning a 0 value");			return 0;		}	}				public void printTrafficVolumeatNode() {		System.out.println("Traffic prdouced at each node:  ");		for(int i=0; i<TrafficProducedataNode.length;i++)			System.out.print(TrafficProducedataNode[i] + " ");		System.out.println();		System.out.println("Traffic Attracted to each node:  ");		for(int i=0; i<TrafficAttractedtoaNode.length;i++)			System.out.print(TrafficAttractedtoaNode[i] + " ");		System.out.println();		System.out.println();	}		public void printTrafficonaLink() {		System.out.println("Traffic on each Link(arc): ");		for(int i=0; i<TrafficProducedataNode.length;i++) {			TrafficonaLink[i].print_stack();		}		System.out.println();	}		public float avgTrafficonLinks(DirectedGraph dgraph){	float avgTraffic=0;	float sum=0;		for(int i=0;i<vertices;i++)			for(int j=0;j<dgraph.NoofLinks(i+1);j++)				{					sum+=TrafficonaLink[i].access(j);						}	avgTraffic=sum/dgraph.Edges() ;				return avgTraffic;					}		public float vkt(DirectedGraph dgraph){	float vkt=0;		for(int i=0;i<vertices;i++)			for(int j=0;j<dgraph.NoofLinks(i+1);j++)				{					vkt+=TrafficonaLink[i].access(j)*dgraph.linkLength[i][j];						}					return vkt;					}		public float vht(DirectedGraph dgraph){	float vht=0;		for(int i=0;i<vertices;i++)			for(int j=0;j<dgraph.NoofLinks(i+1);j++)				{					if(dgraph.Speed(i+1,j+1)!=0.0)						vht+=TrafficonaLink[i].access(j)*dgraph.linkLength[i][j]/dgraph.Speed( i+1,j+1);						}					return vht;					}		public void writeODmatrixFile(DijkstrasAlgo dalgo, DirectedGraph dgraph){		PrintWriter ODmatrix=null;		try			{					ODmatrix=new PrintWriter(new FileOutputStream("ODmatrix.txt"));									}				  				catch(IOException e)			{				System.out.print("Error opening the files!");				System.exit(0);							}		ODmatrix.print("Destination"+"\t"+"Trip(s)"+"\n");				int totalTrip=0;		for(int m=0;m<dgraph.Vertices() ;m++){			ODmatrix.print("Origin"+"\t"+(m+1)+"\n");			for(int n=0;n<dgraph.Vertices();n++){				//System.out.print((m+1) +"\n");				if(m!=n){								ODmatrix.print((n+1)+":\t"+ODMatrix( m,n,(float)dalgo.pLabel( m+1, n+1))+";\n");						totalTrip+=ODMatrix( m,n,(float)dalgo.pLabel( m+1, n+1));				}				}		}				ODmatrix.print(":\ntotal Trips="+totalTrip+"\n");		ODmatrix.close();					}	public void writeFlowFile(DijkstrasAlgo dalgo,DirectedGraph dgraph){		PrintWriter FlowOnlink=null;		try			{					FlowOnlink=new PrintWriter(new FileOutputStream("FlowOnLink.txt"));									}				  				catch(IOException e)			{				System.out.print("Error opening the files!");				System.exit(0);							}		FlowOnlink.print("ODcost Matrix"+"\n");		FlowOnlink.print("Origin"+"\t"+"Destination"+"\t"+"ODCost"+"\n");		for(int m=0;m<dgraph.Vertices() ;m++){			for(int n=0;n<dgraph.Vertices();n++){				//System.out.print((m+1) +"\n");				FlowOnlink.print((m+1)+"\t"+(n+1)+"\t"+dalgo.pLabel(m+1,n+1)+"\n");							}		}										FlowOnlink.print("\nTraffic Flow on links"+"\n");		FlowOnlink.print("Origin"+"\t"+"Destination"+"\t"+"Flow"+"\n");		for(int m=0;m<dgraph.Vertices() ;m++){			for(int n=0;n<dgraph.NoofLinks( m+1);n++){				//System.out.print((m+1) +"\n");				int endnode=dgraph.EndNodeNumbers( m+1,n+1);				FlowOnlink.print((m+1)+"\t"+endnode+"\t"+TrafficonaLink[m].access( n)+"\n");							}		}						FlowOnlink.close();							}		}