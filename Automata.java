import java.io.*;import java.util.Random;import java.net.*;/*automata is completely in first quadrant of the xy plane with its left bottim cellhaving (0, 0) coordinates and top right cell having (size-1, size-1) coordinatesno. of properties of the cells is initialized to 10 unless specified.*/ public class Automata {	private int AutomataSize;	private int NearestNN[][], Population[][];	private float LandUse[][], LandUse2[][];	//landuse is trip generation and landuse2 is trip attraction	boolean  downtown = false;	public URL url;		public Automata() {		this.AutomataSize = -1;	}		/*		Similar to the nextInt(int n) available in java2. Since this function is not working in my comp		a similar implementation is adopted here		do {					bits = r.nextInt();					val = bits%pop;				} while (bits - val + (pop-1) < 0);  	*/		public void automata(URL url,int gridsize, int pop, int landmin, int landmax, boolean downTown) {		Random r = new Random();		int bits, val;		this.url =url;		downtown = downTown;				this.AutomataSize = gridsize;		//System.out.print("automataSize="+AutomataSize);		NearestNN = new int[AutomataSize][AutomataSize];		Population = new int[AutomataSize][AutomataSize];		LandUse = new float [AutomataSize][AutomataSize];		LandUse2 = new float [AutomataSize][AutomataSize];				for(int i=0; i<AutomataSize;i++) {			for(int j=0; j<AutomataSize; j++) {				do {					bits = r.nextInt();					val = bits%pop;				} while (bits - val + (pop-1) < 0);				Population[i][j] = 21+ val; 			}		}						////////// landuse --- traffic produced, landuse2 -traffic attracted		//// the following code generates a uniformly distributed landuse and landuse2		if(landmin>=0){						if(downtown)			/// distributes landuse and landuse2 using exponential functions			//exponential( landmin, landmax);				exponential( landmin, landmax);			else {				int land = landmax - landmin +1;				for(int i=0; i<AutomataSize;i++) {					for(int j=0; j<AutomataSize; j++) {						do {							bits = r.nextInt();							val = bits%land;						} while (bits - val + (land-1) < 0);						LandUse[i][j] = landmin+val; 					}				}							for(int i=0; i<AutomataSize;i++) {					for(int j=0; j<AutomataSize; j++) {						do {							bits = r.nextInt();							val = bits%land;						} while (bits - val + (land-1) < 0);						LandUse2[i][j] = landmin+val; 					}				}			}		}		else{						changeOriginalLanduse(-landmin);					}									}		public void exponential(int minLand, int maxLand) {				int Max = AutomataSize;		int coordCorrection;   ///// shifting the origin to center of the plane for caluclation purpose				coordCorrection = (Max %2 == 0)? (int)(Max/2) :  (int)(Math.floor(Max/2) )   ;		int length = (int) (0.9 * Max/2);				float factor = (float) (Math.sqrt(    Math.log( maxLand   )    )  /   length   ) ;				float sum=0; ////				int dist = length + (int) (0.05*Max);//dist=0.5Max		int height = maxLand - minLand ;		int correctedI = 0, correctedJ = 0;				for(int i=0; i<Max; i++) {			for(int j=0; j<Max; j++) {				correctedI = i-dist;				correctedJ = j-dist;				float f = (float) ( Math.exp( -factor*factor*( correctedI * correctedI + correctedJ*correctedJ )  )  );				sum += height*f;				//LandUse[i][j] = (int)   ( 0.8*maxLand - height *f  );    //// LandUse is production				LandUse2[i][j] = (int) (minLand + height *f );		///// LandUse2 is attraction			}		}					float Max_sqr = (float)(Max*Max);			float B = (float) ( minLand + 2*sum/ Max_sqr    );						for(int i=0; i<Max; i++) {			for(int j=0; j<Max; j++) {				correctedI = i-dist;				correctedJ = j-dist;				float f = (float) ( Math.exp( -factor*factor*( correctedI * correctedI + correctedJ*correctedJ )  )  );				LandUse[i][j] = (int) (B - height*f);			}					}									}			void changeOriginalLanduse(int networksize) {		float landusevector[]=new float[2*AutomataSize*AutomataSize];		InputStream landuses = null;		String filename="RandomLanduse-"+networksize+".txt";		if(networksize==99)filename="RandomLanduse-river.txt";		//System.out.println("\nurl="+url);		try {			landuses = new URL(url, filename).openStream();			//fin = new FileInputStream(filename);		} catch(IOException e) {			System.out.println("Exception Occured!!!!");		}		//System.out.println("edges="+edges);		int temp=0;		try{			temp=landuses.read();		}catch (IOException e){System.out.println("not read!!!!");}		int i=0;		while(i<2*AutomataSize*AutomataSize){			String landuse = "";			//System.out.println("temp="+(char)temp);				while((temp>=(int)'0' && temp<=(int)'9' )|| temp==(int)'.')						{				landuse = landuse+(char)temp;								try{					temp=landuses.read();				}catch (IOException e){System.out.println("not read!!!!");}									//////  32 ---- space, 13 ----- new Ltempne			} 			//System.out.println(landuse);			try {				if(landuse != null)  {						landusevector[i] = Float.valueOf(landuse).floatValue();					i++;				}				}	catch(NumberFormatException e) {				System.out.println("NumberFormatException while reading an float.");			}			//System.out.println(speedvector[i]);							try{				temp=landuses.read();			}catch (IOException e){System.out.println("not read!!!!");}		}			int pointer=0;		for(int j=0; j<AutomataSize;j++) {			for(int k=0; k<AutomataSize; k++) {				LandUse[j][k] = landusevector[pointer];pointer++;				LandUse2[j][k] = landusevector[pointer];pointer++; 			}		}			try{			landuses.close() ;		}catch (IOException e){System.out.println("Cannot close the file!!!!");}	 										}						//////////////////////////////////// function for reading (i, j) th cell and finding the nearest netwrok node in a directed graph						int FindNearestNN(int xcoord, int ycoord, DirectedGraph dg) {			int xsmall, xlarge, ysmall, ylarge,vertices = dg.Vertices();			IntStack  distance, nodenumber;			boolean xinrange, yinrange;			float f = (float)1.5; ////f - fractions the ca side is divided									distance = new IntStack((int)(vertices/4));    /////// even though there are 9 pieces 6 is used to handle the denser locations			nodenumber = new IntStack((int)(vertices/4));						xsmall = (xcoord-(int)(AutomataSize/f)>0)?xcoord-(int)(AutomataSize/f):0;			xlarge = (xcoord+(int)(AutomataSize/f)<AutomataSize)?xcoord+(int)(AutomataSize/f):AutomataSize;						ysmall = (ycoord-(int)(AutomataSize/f)>0)?ycoord-(int)(AutomataSize/f):0;			ylarge = (ycoord+(int)(AutomataSize/f)<AutomataSize)?ycoord+(int)(AutomataSize/f):AutomataSize;						for(int i=0; i<vertices;i++) {				xinrange = (dg.XCoordinate(i+1) <= xlarge && dg.XCoordinate(i+1) >= xsmall )?true:false;				yinrange = (dg.YCoordinate(i+1) <= ylarge && dg.YCoordinate(i+1) >= ysmall )?true:false;								if( xinrange && yinrange ) {					nodenumber.push(i+1);				}			}						int temp =0;			double tempDistanceSquare,xDistanceSquare,yDistanceSquare;			for(int i=1; i<=nodenumber.noofelements()-1;i++) {				{					tempDistanceSquare=Math.pow(dg.XCoordinate(nodenumber.access(temp)) - xcoord, 2) + Math.pow(dg.YCoordinate(nodenumber.access(temp)) - ycoord ,2);					xDistanceSquare=Math.pow(dg.XCoordinate(nodenumber.access(i)) - xcoord, 2);					yDistanceSquare=Math.pow(dg.YCoordinate(nodenumber.access(i)) - ycoord, 2);					if(xDistanceSquare>tempDistanceSquare || yDistanceSquare>tempDistanceSquare)						{}					else if( xDistanceSquare+yDistanceSquare <=tempDistanceSquare)							{temp = i;							}				}							}						return nodenumber.access(temp);					}						//////////////////////////////////// End of fucntion		////////////////////   Function to assign nearest netwrok node to each cell in the automata	public void AssignNearestNode( DirectedGraph dgraph) {		for(int i=0; i<AutomataSize; i++) {			for(int j=0; j<AutomataSize; j++) {				NearestNN[i][j] = FindNearestNN(i,j,dgraph);			}		}	}	//////////////////// End of Nearest network node assigning function 			/////////////////////////Print to screen functions/*	public void printNearestNN() {		System.out.println("The nearest node matrix for the given directed graph;");		for(int i=AutomataSize-1; i>=0; i--) {			for(int j=0; j<AutomataSize; j++) {				System.out.print(NearestNN[j][i] + " ");			}			System.out.println();		}		System.out.println();	}		public void printPopulation() {		for(int i=0; i<AutomataSize; i++) {			for(int j=0; j<AutomataSize; j++) {				System.out.print(Population[i][j] + " ");			}			System.out.println();		}		System.out.println();	}		public void printLandUse() {		for(int i=0; i<AutomataSize; i++) {			for(int j=0; j<AutomataSize; j++) {				System.out.print(LandUse[i][j] + " ");			}			System.out.println();		}		System.out.println();	}		public void printLandUse2() {		for(int i=0; i<AutomataSize; i++) {			for(int j=0; j<AutomataSize; j++) {				System.out.print(LandUse2[i][j] + " ");			}			System.out.println();		}		System.out.println();	}*/		//////////////////// end of functions that print automata variables to screen		////////////////////  Fucntions that return the automata variables	public int   size() {		return AutomataSize;	}			public int nearestnn(int i, int j) {		if(i<AutomataSize && i>=0)			if(j<AutomataSize && j>=0)				return(NearestNN[i][j]);			else {				System.out.println("From Automata calss: Invalid cell coordinates in nearestnn. Cell coordinates belongs to the set [0, 1, 2,.....size-1]");				return(0);			}		else{				System.out.println("From Automata calss: Invalid cell coordinates nearestnn. Cell coordinates belongs to the set [0, 1, 2,.....size-1]");				return(0);		}	}			public int population(int i, int j) {		if(i<AutomataSize && i>=0)			if(j<AutomataSize && j>=0)				return(Population[i][j]);			else {				System.out.println("From Automata calss: Invalid cell coordinates in population. Cell coordinates belongs to the set [0, 1, 2,.....size-1]");				return(0);			}		else{				System.out.println("From Automata calss: Invalid cell coordinates in population. Cell coordinates belongs to the set [0, 1, 2,.....size-1]");				return(0);		}	}		public float landuse(int i, int j) {		if(i<AutomataSize && i>=0)			if(j<AutomataSize && j>=0)				return(LandUse[i][j]);			else {				System.out.println("From Automata calss: Invalid cell coordinates in landuse. Cell coordinates belongs to the set [0, 1, 2,.....size-1]");				return(0);			}		else{				System.out.println("From Automata calss: Invalid cell coordinates in landuse. Cell coordinates belongs to the set [0, 1, 2,.....size-1]");				return(0);		}	}		public float landuse2(int i, int j) {		if(i<AutomataSize && i>=0)			if(j<AutomataSize && j>=0)				return(LandUse2[i][j]);			else {				System.out.println("From Automata calss: Invalid cell coordinates in landuse. Cell coordinates belongs to the set [0, 1, 2,.....size-1]");				return(0);			}		else{				System.out.println("From Automata calss: Invalid cell coordinates in landuse. Cell coordinates belongs to the set [0, 1, 2,.....size-1]");				return(0);		}	}		//////////////////// end of functions that return automata variables	}