public class Revenue {	private float tax;	private float coeffLength;	private float coeffFlow ;	private float  coeffSpeed;	private FloatStack AvailableRevenue[];	private FloatStack TaxonaLink[];	private int vertices = 0;		public Revenue() {	}		public Revenue(DirectedGraph dgraph, float tax, float coeffL, float coeffF, float coeffS) {				vertices = dgraph.Vertices();		this.tax = tax;		coeffLength = coeffL;		coeffFlow = coeffF;		coeffSpeed = coeffS;		AvailableRevenue = new FloatStack[vertices];		for(int i=0; i<vertices; i++) {			AvailableRevenue[i] = new FloatStack(dgraph.NoofLinks(i+1));			for(int j=0; j<dgraph.NoofLinks(i+1); j++) {				AvailableRevenue[i].push( 0 );			}		}					}		public void flushAvailableRevenue(DirectedGraph dgraph) {		for(int i=0; i<vertices; i++) {			for(int j=0; j<dgraph.NoofLinks(i+1); j++) {				AvailableRevenue[i].replace( j, 0 );			}		}	}		public void changeTax(float tax) {		this.tax= tax;	}		public void revenue ( DirectedGraph dgraph,  TAssignment tassign  ) {		for(int i=0; i<vertices; i++) {			for(int j=0; j<dgraph.NoofLinks(i+1); j++) {				float lengthTerm = (float) Math.pow( dgraph.Read_Distance(i+1, dgraph.EndNodeNumbers(i+1, j+1)) , coeffLength);				float flowTerm = (float)( 365* Math.pow(tassign.TrafficonaLink_2(dgraph, i+1,  j+1), coeffFlow)    );				float speedTerm = (float)Math.pow( dgraph.Speed(i+1, j+1),  coeffSpeed);				AvailableRevenue[i].replace(j, AvailableRevenue[i].access(j)+(float) ( tax* lengthTerm* flowTerm*speedTerm) );   /////  			}		}			}				///////  FirstNN, SecondNN = {1,2,3,...vertices } and must be connected	public float AvailableRevenue(DirectedGraph  dgraph, int FirstNN, int SecondNN) {		float revenue = 0;		if(dgraph.Connected(FirstNN, SecondNN)) {			int position = dgraph.Position_EndNode(FirstNN, SecondNN);			revenue = AvailableRevenue[FirstNN-1].access(position-1);		} else			System.out.println("From Revenue class, AvailableRevenue method: Nodes are not connected returning 0 value");				return revenue;	}		////////    FirstNN, SecondNN = {1,2,3....vertices} and must be connected	public void Change_AvailableRevenue(DirectedGraph dgraph, int FirstNN, int SecondNN, float value) {		if(dgraph.Connected(FirstNN, SecondNN) ) {			int position = dgraph.Position_EndNode(FirstNN, SecondNN);			AvailableRevenue[FirstNN-1].replace(position-1,  AvailableRevenue[FirstNN-1].access(position-1)+value);		} else			System.out.println("From Revenue class, Change_AvailableRevenue method:  Nodes are not connected, so revenue is not changed!!!");	}				/////	public void printAvailableRevenue() {		System.out.println();		System.out.println("Available Revenue on each link:");		for(int  i=0; i<vertices; i++)			AvailableRevenue[i].print_stack();		System.out.println();			}		}