import java.io.*;	import java.net.*;public class NetworkDynamics {	String inputFile;	public URL url;	public int endyear;	private int speed1   =  5;		// var0:Speed1	private int speed2   =  5;		// var1:Speed2	int Max;		//     var2:doesn't exist just value of X used for drawing output	private int landmin   =   10;		// var3:U(min)	Land use minimum	private int landmax   =  10;		//  var4:U(max)  land use maximum	private boolean  downTown  =  false;		//var5: downtown?	private float  vot       =   (float) 1.0 ;		//var6:  value of time	private float trate    =  (float) 1.0;		//   var7:tax rate    rate to calculate cost of commuting	private float lengthrate    =   (float) 1.0; 		//var8:  power of length term	private float speedrate   =  (float) 0.0;	//   var9:power of speed term	private float coeff      =     (float) 0.01;	//    var10:coeff in trip distribution (friction factor)	private boolean symmetry   =   true;	//   var11:symm route assign?	private boolean avgSpeeds   =   true;	//   var12:avg. speeds?	private float  tax    =   (float) 1.0 ;	//  var13:tax 	private float coeffLength   =   (float)1.0;	//  var14:power of length in revenue function		private float coeffFlow = (float) 1;   ///// *****:power of flow term in revenue function is always one. 						 ///// No provision to change this value is provided in the program		private float coeffSpeed    =   (float) 0.0;	//var15:  power of speed terim in revnue function	private float costrate   =   (float) 365;	//	var16:rate term in cost function	private float lcoeff  =  (float)  1.0;	//	var17:power of length term in cost function	private float fcoeff     =  (float) 0.75 ;	//	var18:power of flow term in cost function	private float scoeff   = (float) 0.75;	//	var19:power of speed term in cost function	private float srf    =   (float) 1.0;	//	var20:speed reduction factor(beta)	private int X   =  0 ;	//var21:	X		private int tPeriod = 20;    ////var22: time period of evolution			/////////////////////////////////////////////////////////////   Components of Network dynamix	///////////////////////////////////////////////////////////// 	DirectedGraph dg;	Automata ca;	DijkstrasAlgo dalgo;	TAssignment tassign;	Revenue reven;	Investment2 Invest;	/////////////////////////////////////////////////////////////   Components of Network dynamix	///////////////////////////////////////////////////////////// 		///////////////////////////////////////////////////////////////    Output variables 	/////////////////////////////////////////////////////////////// 	FloatStack  Speed[][];	FloatStack  Volume[][];		//	float avgSpeed[];//	float varianceSpeed[] ;	//	float avgVolume[];//	float varianceVolume[];	float avgSpeed;	float avgVolume;	float vkt;	float vht;	float totalCost;	float totalRevenue;	float cumulativeRevenue;	float cumulativeCost;		double ImproveTerm;		Demo demo;	///////////////////////////////////////////////////////////////    Output variables 	/////////////////////////////////////////////////////////////// 			// Constructors		public NetworkDynamics() {	}	public NetworkDynamics( float  vars[], URL url,  String inputFileName) throws IOException{						inputFile = inputFileName;					setVariables( vars );			this.url =url;/////SET UP DIRECTEDGRAPH					//System.out.print("here speed1="+speed1+"\n");						dg = new DirectedGraph(url, inputFile, speed1, speed2);				/////CALCULATE MAX			{			int MaxX, MaxY;			int MinX, MinY;							MaxX = dg.XCoordinate(1);			MinX = dg.XCoordinate(1);			for(int i=2; i<=dg.Vertices(); i++) {				if(dg.XCoordinate(i) < MinX)					MinX = dg.XCoordinate(i);				if(dg.XCoordinate(i) > MaxX)					MaxX = dg.XCoordinate(i);			}					MaxY = dg.YCoordinate(1);			MinY = dg.YCoordinate(1);			for(int i=2; i<=dg.Vertices(); i++) {				if(dg.YCoordinate(i) < MinY)					MinY = dg.YCoordinate(i);				if(dg.YCoordinate(i) > MaxY)				MaxY = dg.YCoordinate(i);			}					// The distance between farthest points in the graph along x or y direction(we dont care the direction) 			Max = ((MaxX+MinX)>(MaxY+MinY)) ? (MaxX+MinX) : (MaxY+MinY);			Max++;		}													}			public NetworkDynamics( float  vars[], URL url,  String inputFileName, Demo demo) throws IOException{						this.demo=demo;			this.url =url;			inputFile = inputFileName;					setVariables( vars );/////SET UP DIRECTEDGRAPH		  			//System.out.print("vars[0]="+vars[0]+"\tspeed1="+speed1+"\n");			dg = new DirectedGraph(url, inputFile, speed1, speed2,demo);					/////CALCULATE MAX			{			int MaxX, MaxY;			int MinX, MinY;							MaxX = dg.XCoordinate(1);			MinX = dg.XCoordinate(1);			for(int i=2; i<=dg.Vertices(); i++) {				if(dg.XCoordinate(i) < MinX)					MinX = dg.XCoordinate(i);				if(dg.XCoordinate(i) > MaxX)					MaxX = dg.XCoordinate(i);			}					MaxY = dg.YCoordinate(1);			MinY = dg.YCoordinate(1);			for(int i=2; i<=dg.Vertices(); i++) {				if(dg.YCoordinate(i) < MinY)					MinY = dg.YCoordinate(i);				if(dg.YCoordinate(i) > MaxY)				MaxY = dg.YCoordinate(i);			}					// The distance between farthest points in the graph along x or y direction(we dont care the direction) 			Max = ((MaxX+MinX)>(MaxY+MinY)) ? (MaxX+MinX) : (MaxY+MinY);			Max++;		}												}	///////	/// End of constructors		private void setVariables(float vars[]) {						speed1 = (int)vars[0];			speed2 = (int) vars[1];			//// var3 = vars[2]   -----  a blank dummy var			landmin = (int) vars[3];			landmax = (int) vars[4];			downTown = ((int) vars[5]) == 0? false: true;			vot = (float) vars[6];			trate =  (float) vars[7];			lengthrate = (float) vars[8];			speedrate = (float) vars[9];			coeff = (float)  vars[10];			symmetry = ( (int) vars[11] == 0) ? false: true;			avgSpeeds = ( (int) vars[12] == 0) ? false: true;			tax = (float) vars[13];			coeffLength = (float) vars[14];			coeffSpeed = (float)  vars[15];			costrate = (float)  vars[16];			lcoeff = (float) vars[17];			fcoeff = (float) vars[18];			scoeff = (float) vars[19];			srf = (float) vars[20];			X = (int) vars[21];			tPeriod = (int) vars[22];				}					public void NetworkDynamix( URL url,float vars[]) {				int vertices, edges;		int Max=this.Max ;		cumulativeRevenue=0;		cumulativeCost=0;				demo.dp.showStatus.setText("Network initializing...");		demo.dp.showStatus.repaint() ;				setVariables( vars);				//System.out.print("url="+dg.url+"\n");				dg.changeSpeeds( speed1, speed2,url);				//dg.changeOriginalSpeeds();							//dg = new DirectedGraph(inputFileName, speed1, speed2);		vertices = dg.Vertices();		edges = dg.Edges();				///// intitalize output variables		Speed = new FloatStack[tPeriod+1][vertices];		Volume = new FloatStack[tPeriod+1][vertices];		//avgSpeed = new float[tPeriod+1];		//varianceSpeed = new float[tPeriod+1];		//avgVolume = new float[tPeriod];		//varianceVolume = new float[tPeriod];		//////////////////////////////////////////////////					//////CALL AUTOMATA//////////////				ca = new Automata();		ca.automata(url,Max,5, landmin, landmax, downTown);		ca.AssignNearestNode(dg);//		System.out.println("End of land use allocation");//////CALL DALGO///////////////////		System.out.println("Starting shortest path calculation");					dalgo = new DijkstrasAlgo( vot, trate, lengthrate, speedrate,dg,symmetry);		//dalgo.dijkstrasalgo(dg);//		System.out.println("End of shortest path calculation");			////// initializing///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////		//////CALL TASSIGN////////////////		tassign = new TAssignment(coeff);				//writeLinkInfoFiles(dg);				//////CALL REVENUE//////////////				reven = new Revenue(dg, tax, coeffLength, coeffFlow, coeffSpeed);		//////CALL INVEST//////////////				Invest = new Investment2(costrate, lcoeff, fcoeff, scoeff, srf, X, avgSpeeds);					for(int p=0; p<vertices; p++) {			Speed[0][p] = new FloatStack( dg.NoofLinks(p+1) );			for(int q=0; q<dg.NoofLinks(p+1); q++) {				float temp=dg.Speed( p+1,q+1);								Speed[0][p].push(dg.Speed( p+1,q+1) );				}			}						for(int p=0; p<vertices; p++) {			Volume[0][p] = new FloatStack( dg.NoofLinks(p+1) );			for(int q=0; q<dg.NoofLinks(p+1); q++) {								Volume[0][p].push(0);				}			}									//avgSpeed[0] = dg.avgSpeed();		//varianceSpeed[0] = dg.varianceSpeed();		/////////////////////////////////////////////////////////////////////////////////////////ITERATIONS!!!///////////////////////////////////////////////////////  System.out.print("vertices="+vertices+"\n");   for(int p=0; p<vertices; p++) {	  for(int q=0; q<dg.NoofLinks(p+1); q++) {						  System.out.print((p+1)+"\t"+dg.EndNodeNumbers(p+1,q+1)+"\n");	  }	  }	  		endyear=tPeriod-1;		for(int j=0; j<tPeriod; j++) 		{			if(j==0)			{demo.dp.showStatus.setText("The 1st iteration running...");			}			else if(j==1)			{demo.dp.showStatus.setText("The 2nd iteration running...");			}			else if (j==2)			{demo.dp.showStatus.setText("The 3rd iteration running...");			}			else			{demo.dp.showStatus.setText("The "+Integer.toString( j+1)+"th iteration running...");			}			demo.dp.showStatus.repaint() ;									dalgo.dijkstrasalgo(dg);			//dalgo.print_TVector();			//dalgo.print_PermanentLabel();			//dalgo.print_AdjacentNode();			demo.dp.showStatus.setText("End of finding the shortest path...");			demo.dp.showStatus.repaint() ;									/////        Traffic generation, Trip distribution and trip assignment			tassign.trafficassignment(dg, ca, dalgo, symmetry,demo,j);			//System.out.println("End of Traffic Assignment");			//tassign.printTrafficonaLink();			//demo.dp.showStatus.setText("End of trip distribution and traffic assignment...");			//demo.dp.showStatus.repaint() ;											/////      Calculates the revenue available on each link depending on the tax imposed on each link			reven.revenue(dg, tassign);			//  System.out.println("End of Revenue");			//reven.printAvailableRevenue();			//dg.printSpeed();						//////    Using the revenue obtained maintain and upgrade the links			Invest.InvestontheRoads(dg, tassign, reven);						cumulativeCost+=Invest.totalCost;			cumulativeRevenue+=Invest.totalRevenue ; 				// System.out.println("End of Investment");			//reven.printAvailableRevenue();			// dg.printSpeed();			//dg.speedStatistics();			//System.out.println( "End of the jth year:j="+j);										for(int p=0; p<vertices; p++) {				Speed[j+1][p] = new FloatStack( dg.NoofLinks(p+1) );				Volume[j+1][p] = new FloatStack( dg.NoofLinks(p+1) );								for(int q=0; q<dg.NoofLinks(p+1); q++) {					Speed[j+1][p].push(dg.Speed(p+1, q+1));						 Volume[j+1][p].push(  tassign.TrafficonaLink[p].access(q)  );									}			}						//System.out.print(j+"\t"+Invest.ImproveTerm+"\n");			if(Invest.ImproveTerm<0.000001){endyear=j;break;}			 						}//end of S				//Calculate MOE's after the last iteration		  					  avgSpeed=dg.avgSpeed() ;										  avgVolume=tassign.avgTrafficonLinks(dg );					  vkt=tassign.vkt( dg);					  vht=tassign.vht( dg);					  totalCost=Invest.totalCost ;					  totalRevenue=Invest.totalRevenue ;					  ImproveTerm=Invest.ImproveTerm ;																					Invest.resetLinks();		dg.resetSpeed(url);		reven.flushAvailableRevenue(dg);		demo.dp.showStatus.setText("End of Network Dynamics.");		demo.dp.showStatus.repaint() ;						if(ImproveTerm<0.000001){			demo.dp.showStatus.setText("End of Network Dynamics (Equilibrium Reached).");			demo.dp.showStatus.repaint() ;		}		else{			demo.dp.showStatus.setText("End of Network Dynamics (Equilibrium Not Reached).");			demo.dp.showStatus.repaint() ;						}							}		///  End of networkDynamix													float getSpeed(int node1,int node2,int tperiod){		float temp=0;		if(dg.Connected( node1,node2)){			for(int k=0;k<dg.NoofLinks( node1);k++){				if(dg.EndNodeNumbers( node1,k+1)==node2){					temp= Speed[tperiod+1][node1-1].access(k);					return temp;				}			}						}		return temp;	}	float getVolume(int node1,int node2){		float temp=0;		if(dg.Connected( node1,node2)){			for(int k=0;k<dg.NoofLinks( node1);k++){				if(dg.EndNodeNumbers( node1,k+1)==node2){					temp=tassign.TrafficonaLink [node1-1].access(k);					return temp;				}			}						}		return temp;	}							void writeMe(int intVal, FileOutputStream fout) throws IOException {		String s = Integer.toString(intVal);				for(int i=0; i<s.length(); i++)			fout.write( (int)(    s.charAt(i)   )   );					}		void writeMe(float floatVal, FileOutputStream fout) throws IOException {		String s = Float.toString(floatVal);				for(int i=0; i<s.length(); i++)			fout.write( (int)(    s.charAt(i)   )   );					}								public void writeLinkInfoFiles(DirectedGraph dg){		PrintWriter LinkInfo=null;		float length=5;		//System.out .print("strange!\n");		try			{				LinkInfo=new PrintWriter(new FileOutputStream("LinkInfo.txt"));					}				  				catch(IOException e)			{				System.out.print("Error opening the files!");				System.exit(0);							}		LinkInfo.print("Origin"+"\t"+"Destination"+"\t"+"Length"+"\t"+"Travel Time"+"\n");			for(int m=0;m<dg.Vertices() ;m++)			for(int n=0;n<dg.NoofLinks( m+1);n++){				if(dg.Speed( m+1,n+1)<0.000001)dg.Speed [m].replace(n,(float)0.000001);				LinkInfo.print((m+1)+"\t"+dg.EndNodeNumbers( m+1,n+1)+"\t"+length+"\t"+length/dg.Speed( m+1,n+1)+"\n");						}		LinkInfo.close();						}			}