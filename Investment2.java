public class Investment2 {		public float totalCost;	public float totalRevenue;	public double ImproveTerm;		private float costRate;	private float lengthCoeff;	private float flowCoeff;	private float speedCoeff;	private float speedReductionFactor;	boolean averageSpeeds;	private int X;		public int linksDegraded = 0;	public int linksImproved = 0;		public Investment2() {	}		public Investment2(float cRate, float lCoeff, float fCoeff, float sCoeff, float srf, int X, boolean avgSpeeds) {				costRate = cRate;		lengthCoeff = lCoeff;		flowCoeff = fCoeff;		speedCoeff = sCoeff;		speedReductionFactor = srf;		this.X = X;		averageSpeeds = avgSpeeds;			}			public void InvestontheRoads(DirectedGraph dgraph, TAssignment tassign, Revenue money) {				linksDegraded = 0;		linksImproved = 0;		totalCost=0;		totalRevenue=0;		ImproveTerm=0;				float Cost;		int vertices = dgraph.Vertices();				for(int i=0; i<vertices; i++) {			for(int j=0; j< dgraph.NoofLinks(i+1); j++) {				float lengthTerm = (float) Math.pow(dgraph.Read_Distance(i+1, dgraph.EndNodeNumbers(i+1, j+1)),   lengthCoeff    );				float flowTerm = (float) Math.pow(tassign.TrafficonaLink_2(dgraph, i+1, j+1) , flowCoeff);				float speedTerm = (float) Math.pow(dgraph.Speed(i+1, j+1),    speedCoeff);				Cost = (float) ( costRate*lengthTerm * flowTerm*speedTerm) ;				if(Cost==0)ImproveTerm+=0;				else					ImproveTerm+=Math.pow((money.AvailableRevenue(dgraph, i+1, dgraph.EndNodeNumbers(i+1, j+1))/Cost-1),2);												totalCost+=Cost;				totalRevenue+=money.AvailableRevenue(dgraph, i+1, dgraph.EndNodeNumbers(i+1, j+1));				if(Cost<0.000001)Cost=(float)0.000001;				if(money.AvailableRevenue(dgraph, i+1, dgraph.EndNodeNumbers(i+1, j+1)) < Cost   )					linksDegraded++;				else					linksImproved++;								float newSpeed = (float)(dgraph.Speed(i+1, j+1)*Math.pow ( (  X + money.AvailableRevenue(dgraph, i+1, dgraph.EndNodeNumbers(i+1, j+1))  ) / ( Cost + X)  ,   speedReductionFactor )   );				//System.out.print("Cost="+costRate+"\t"+lengthTerm+"\t"+flowTerm+"\t"+speedTerm+"\t\n");				dgraph.change_Speed(i+1, dgraph.EndNodeNumbers(i+1, j+1),  newSpeed );				money.Change_AvailableRevenue(dgraph, i+1, dgraph.EndNodeNumbers(i+1, j+1), -money.AvailableRevenue(dgraph, i+1, dgraph.EndNodeNumbers(i+1, j+1))); 										}		}				if(averageSpeeds) {			for(int i=0; i < vertices; i++) {				for(int j=0; j<dgraph.NoofLinks(i+1); j++) {					int NN = dgraph.EndNodeNumbers(i+1, j+1);					int position = dgraph.Position_EndNode(NN, i+1); 					float newSpeed = (float) ( ( dgraph.Speed(i+1, j+1) + dgraph.Speed(NN, position) ) / 2);					dgraph.change_Speed(i+1, NN, newSpeed);					dgraph.change_Speed(NN, i+1, newSpeed);				}			}				}			}		public void changeLCoeff(float lCoeff) {		lengthCoeff = lCoeff;	}		public void changeSCoeff(float sCoeff) {		speedCoeff = sCoeff;	}			public void changeSRF(float srf) {		speedReductionFactor = srf;	}		public void resetLinks() {		linksDegraded = 0;		linksImproved = 0;	}		}